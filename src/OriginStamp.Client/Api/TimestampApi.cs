/*
 * OriginStamp Client
 *
 * OpenAPI spec version: 3.0
 * OriginStamp Documentation: https://docs.originstamp.com
 * Contact: mail@originstamp.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using OriginStamp.Client.Client;
using OriginStamp.Client.Model;

namespace OriginStamp.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITimestampApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>DefaultOfTimestampResponse</returns>
        DefaultOfTimestampResponse CreateTimestamp (string authorization, TimestampRequest timestampRequest);

        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>ApiResponse of DefaultOfTimestampResponse</returns>
        ApiResponse<DefaultOfTimestampResponse> CreateTimestampWithHttpInfo (string authorization, TimestampRequest timestampRequest);
        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>DefaultOfTimestampResponse</returns>
        DefaultOfTimestampResponse GetHashStatus (string authorization, string hashString);

        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>ApiResponse of DefaultOfTimestampResponse</returns>
        ApiResponse<DefaultOfTimestampResponse> GetHashStatusWithHttpInfo (string authorization, string hashString);
        /// <summary>
        /// Seed Status
        /// </summary>
        /// <remarks>
        /// With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>DefaultOfTimestampData</returns>
        DefaultOfTimestampData GetSeedStatus (string authorization, string seedId);

        /// <summary>
        /// Seed Status
        /// </summary>
        /// <remarks>
        /// With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>ApiResponse of DefaultOfTimestampData</returns>
        ApiResponse<DefaultOfTimestampData> GetSeedStatusWithHttpInfo (string authorization, string seedId);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of DefaultOfTimestampResponse</returns>
        System.Threading.Tasks.Task<DefaultOfTimestampResponse> CreateTimestampAsync (string authorization, TimestampRequest timestampRequest);

        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of ApiResponse (DefaultOfTimestampResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DefaultOfTimestampResponse>> CreateTimestampAsyncWithHttpInfo (string authorization, TimestampRequest timestampRequest);
        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of DefaultOfTimestampResponse</returns>
        System.Threading.Tasks.Task<DefaultOfTimestampResponse> GetHashStatusAsync (string authorization, string hashString);

        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of ApiResponse (DefaultOfTimestampResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DefaultOfTimestampResponse>> GetHashStatusAsyncWithHttpInfo (string authorization, string hashString);
        /// <summary>
        /// Seed Status
        /// </summary>
        /// <remarks>
        /// With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>Task of DefaultOfTimestampData</returns>
        System.Threading.Tasks.Task<DefaultOfTimestampData> GetSeedStatusAsync (string authorization, string seedId);

        /// <summary>
        /// Seed Status
        /// </summary>
        /// <remarks>
        /// With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>Task of ApiResponse (DefaultOfTimestampData)</returns>
        System.Threading.Tasks.Task<ApiResponse<DefaultOfTimestampData>> GetSeedStatusAsyncWithHttpInfo (string authorization, string seedId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class TimestampApi : ITimestampApi
    {
        private OriginStamp.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="TimestampApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TimestampApi(String basePath)
        {
            this.Configuration = new OriginStamp.Client.Client.Configuration { BasePath = basePath };

            ExceptionFactory = OriginStamp.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TimestampApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public TimestampApi(OriginStamp.Client.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = OriginStamp.Client.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = OriginStamp.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public OriginStamp.Client.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public OriginStamp.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Submission With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>DefaultOfTimestampResponse</returns>
        public DefaultOfTimestampResponse CreateTimestamp (string authorization, TimestampRequest timestampRequest)
        {
             ApiResponse<DefaultOfTimestampResponse> localVarResponse = CreateTimestampWithHttpInfo(authorization, timestampRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Submission With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>ApiResponse of DefaultOfTimestampResponse</returns>
        public ApiResponse< DefaultOfTimestampResponse > CreateTimestampWithHttpInfo (string authorization, TimestampRequest timestampRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->CreateTimestamp");
            // verify the required parameter 'timestampRequest' is set
            if (timestampRequest == null)
                throw new ApiException(400, "Missing required parameter 'timestampRequest' when calling TimestampApi->CreateTimestamp");

            var localVarPath = "/v4/timestamp/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (timestampRequest != null && timestampRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(timestampRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = timestampRequest; // byte array
            }

            // authentication (API Key Authorization) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateTimestamp", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultOfTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultOfTimestampResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultOfTimestampResponse)));
        }

        /// <summary>
        /// Submission With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of DefaultOfTimestampResponse</returns>
        public async System.Threading.Tasks.Task<DefaultOfTimestampResponse> CreateTimestampAsync (string authorization, TimestampRequest timestampRequest)
        {
             ApiResponse<DefaultOfTimestampResponse> localVarResponse = await CreateTimestampAsyncWithHttpInfo(authorization, timestampRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Submission With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the &#39;created&#39; field in the response is set to &#39;false&#39; and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the &#39;seed_id&#39; field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of ApiResponse (DefaultOfTimestampResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DefaultOfTimestampResponse>> CreateTimestampAsyncWithHttpInfo (string authorization, TimestampRequest timestampRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->CreateTimestamp");
            // verify the required parameter 'timestampRequest' is set
            if (timestampRequest == null)
                throw new ApiException(400, "Missing required parameter 'timestampRequest' when calling TimestampApi->CreateTimestamp");

            var localVarPath = "/v4/timestamp/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (timestampRequest != null && timestampRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(timestampRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = timestampRequest; // byte array
            }

            // authentication (API Key Authorization) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateTimestamp", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultOfTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultOfTimestampResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultOfTimestampResponse)));
        }

        /// <summary>
        /// Status This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>DefaultOfTimestampResponse</returns>
        public DefaultOfTimestampResponse GetHashStatus (string authorization, string hashString)
        {
             ApiResponse<DefaultOfTimestampResponse> localVarResponse = GetHashStatusWithHttpInfo(authorization, hashString);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Status This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>ApiResponse of DefaultOfTimestampResponse</returns>
        public ApiResponse< DefaultOfTimestampResponse > GetHashStatusWithHttpInfo (string authorization, string hashString)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetHashStatus");
            // verify the required parameter 'hashString' is set
            if (hashString == null)
                throw new ApiException(400, "Missing required parameter 'hashString' when calling TimestampApi->GetHashStatus");

            var localVarPath = "/v4/timestamp/{hash_string}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (hashString != null) localVarPathParams.Add("hash_string", this.Configuration.ApiClient.ParameterToString(hashString)); // path parameter
            if (authorization != null) localVarHeaderParams.Add("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter

            // authentication (API Key Authorization) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetHashStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultOfTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultOfTimestampResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultOfTimestampResponse)));
        }

        /// <summary>
        /// Status This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of DefaultOfTimestampResponse</returns>
        public async System.Threading.Tasks.Task<DefaultOfTimestampResponse> GetHashStatusAsync (string authorization, string hashString)
        {
             ApiResponse<DefaultOfTimestampResponse> localVarResponse = await GetHashStatusAsyncWithHttpInfo(authorization, hashString);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Status This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All &#39;created&#39; fields are always set to false for a status request.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of ApiResponse (DefaultOfTimestampResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DefaultOfTimestampResponse>> GetHashStatusAsyncWithHttpInfo (string authorization, string hashString)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetHashStatus");
            // verify the required parameter 'hashString' is set
            if (hashString == null)
                throw new ApiException(400, "Missing required parameter 'hashString' when calling TimestampApi->GetHashStatus");

            var localVarPath = "/v4/timestamp/{hash_string}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (hashString != null) localVarPathParams.Add("hash_string", this.Configuration.ApiClient.ParameterToString(hashString)); // path parameter
            if (authorization != null) localVarHeaderParams.Add("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter

            // authentication (API Key Authorization) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetHashStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultOfTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultOfTimestampResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultOfTimestampResponse)));
        }

        /// <summary>
        /// Seed Status With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>DefaultOfTimestampData</returns>
        public DefaultOfTimestampData GetSeedStatus (string authorization, string seedId)
        {
             ApiResponse<DefaultOfTimestampData> localVarResponse = GetSeedStatusWithHttpInfo(authorization, seedId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Seed Status With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>ApiResponse of DefaultOfTimestampData</returns>
        public ApiResponse< DefaultOfTimestampData > GetSeedStatusWithHttpInfo (string authorization, string seedId)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetSeedStatus");
            // verify the required parameter 'seedId' is set
            if (seedId == null)
                throw new ApiException(400, "Missing required parameter 'seedId' when calling TimestampApi->GetSeedStatus");

            var localVarPath = "/v4/timestamp/status/seed/{seed_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (seedId != null) localVarPathParams.Add("seed_id", this.Configuration.ApiClient.ParameterToString(seedId)); // path parameter
            if (authorization != null) localVarHeaderParams.Add("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter

            // authentication (API Key Authorization) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSeedStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultOfTimestampData>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultOfTimestampData) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultOfTimestampData)));
        }

        /// <summary>
        /// Seed Status With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>Task of DefaultOfTimestampData</returns>
        public async System.Threading.Tasks.Task<DefaultOfTimestampData> GetSeedStatusAsync (string authorization, string seedId)
        {
             ApiResponse<DefaultOfTimestampData> localVarResponse = await GetSeedStatusAsyncWithHttpInfo(authorization, seedId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Seed Status With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="seedId">ID of the timestamp seed</param>
        /// <returns>Task of ApiResponse (DefaultOfTimestampData)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DefaultOfTimestampData>> GetSeedStatusAsyncWithHttpInfo (string authorization, string seedId)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetSeedStatus");
            // verify the required parameter 'seedId' is set
            if (seedId == null)
                throw new ApiException(400, "Missing required parameter 'seedId' when calling TimestampApi->GetSeedStatus");

            var localVarPath = "/v4/timestamp/status/seed/{seed_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (seedId != null) localVarPathParams.Add("seed_id", this.Configuration.ApiClient.ParameterToString(seedId)); // path parameter
            if (authorization != null) localVarHeaderParams.Add("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter

            // authentication (API Key Authorization) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSeedStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultOfTimestampData>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultOfTimestampData) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultOfTimestampData)));
        }

    }
}
