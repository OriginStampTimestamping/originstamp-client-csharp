/* 
 * OriginStamp Client
 * 
 * OpenAPI spec version: 3.0
 * OriginStamp Documentation: https://doc.originstamp.org
 * Contact: mail@originstamp.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using OriginStamp.Client.Client;
using OriginStamp.Client.Model;

namespace OriginStamp.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITimestampApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>DefaultTimestampResponse</returns>
        DefaultTimestampResponse CreateTimestamp (string authorization, TimestampRequest timestampRequest);

        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>ApiResponse of DefaultTimestampResponse</returns>
        ApiResponse<DefaultTimestampResponse> CreateTimestampWithHttpInfo (string authorization, TimestampRequest timestampRequest);
        /// <summary>
        /// Usage
        /// </summary>
        /// <remarks>
        /// With this interface you can receive the current api usage.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>DefaultUsageResponse</returns>
        DefaultUsageResponse GetApiKeyUsage (string authorization);

        /// <summary>
        /// Usage
        /// </summary>
        /// <remarks>
        /// With this interface you can receive the current api usage.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>ApiResponse of DefaultUsageResponse</returns>
        ApiResponse<DefaultUsageResponse> GetApiKeyUsageWithHttpInfo (string authorization);
        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>DefaultTimestampResponse</returns>
        DefaultTimestampResponse GetHashStatus (string authorization, string hashString);

        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>ApiResponse of DefaultTimestampResponse</returns>
        ApiResponse<DefaultTimestampResponse> GetHashStatusWithHttpInfo (string authorization, string hashString);
        /// <summary>
        /// Proof
        /// </summary>
        /// <remarks>
        /// This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>byte[]</returns>
        byte[] GetProof (string authorization, ProofRequest proofRequest);

        /// <summary>
        /// Proof
        /// </summary>
        /// <remarks>
        /// This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>ApiResponse of byte[]</returns>
        ApiResponse<byte[]> GetProofWithHttpInfo (string authorization, ProofRequest proofRequest);
        /// <summary>
        /// Dev
        /// </summary>
        /// <remarks>
        /// With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>Defaultstring</returns>
        Defaultstring TriggerTimestampWebhook (string authorization, WebhookRequest webhookRequest);

        /// <summary>
        /// Dev
        /// </summary>
        /// <remarks>
        /// With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>ApiResponse of Defaultstring</returns>
        ApiResponse<Defaultstring> TriggerTimestampWebhookWithHttpInfo (string authorization, WebhookRequest webhookRequest);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of DefaultTimestampResponse</returns>
        System.Threading.Tasks.Task<DefaultTimestampResponse> CreateTimestampAsync (string authorization, TimestampRequest timestampRequest);

        /// <summary>
        /// Submission
        /// </summary>
        /// <remarks>
        /// You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of ApiResponse (DefaultTimestampResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DefaultTimestampResponse>> CreateTimestampAsyncWithHttpInfo (string authorization, TimestampRequest timestampRequest);
        /// <summary>
        /// Usage
        /// </summary>
        /// <remarks>
        /// With this interface you can receive the current api usage.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>Task of DefaultUsageResponse</returns>
        System.Threading.Tasks.Task<DefaultUsageResponse> GetApiKeyUsageAsync (string authorization);

        /// <summary>
        /// Usage
        /// </summary>
        /// <remarks>
        /// With this interface you can receive the current api usage.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>Task of ApiResponse (DefaultUsageResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DefaultUsageResponse>> GetApiKeyUsageAsyncWithHttpInfo (string authorization);
        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of DefaultTimestampResponse</returns>
        System.Threading.Tasks.Task<DefaultTimestampResponse> GetHashStatusAsync (string authorization, string hashString);

        /// <summary>
        /// Status
        /// </summary>
        /// <remarks>
        /// The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of ApiResponse (DefaultTimestampResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DefaultTimestampResponse>> GetHashStatusAsyncWithHttpInfo (string authorization, string hashString);
        /// <summary>
        /// Proof
        /// </summary>
        /// <remarks>
        /// This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>Task of byte[]</returns>
        System.Threading.Tasks.Task<byte[]> GetProofAsync (string authorization, ProofRequest proofRequest);

        /// <summary>
        /// Proof
        /// </summary>
        /// <remarks>
        /// This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        System.Threading.Tasks.Task<ApiResponse<byte[]>> GetProofAsyncWithHttpInfo (string authorization, ProofRequest proofRequest);
        /// <summary>
        /// Dev
        /// </summary>
        /// <remarks>
        /// With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>Task of Defaultstring</returns>
        System.Threading.Tasks.Task<Defaultstring> TriggerTimestampWebhookAsync (string authorization, WebhookRequest webhookRequest);

        /// <summary>
        /// Dev
        /// </summary>
        /// <remarks>
        /// With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </remarks>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>Task of ApiResponse (Defaultstring)</returns>
        System.Threading.Tasks.Task<ApiResponse<Defaultstring>> TriggerTimestampWebhookAsyncWithHttpInfo (string authorization, WebhookRequest webhookRequest);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class TimestampApi : ITimestampApi
    {
        private OriginStamp.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="TimestampApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TimestampApi(String basePath)
        {
            this.Configuration = new Configuration { BasePath = basePath };

            ExceptionFactory = OriginStamp.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TimestampApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public TimestampApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = OriginStamp.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public OriginStamp.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Submission You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>DefaultTimestampResponse</returns>
        public DefaultTimestampResponse CreateTimestamp (string authorization, TimestampRequest timestampRequest)
        {
             ApiResponse<DefaultTimestampResponse> localVarResponse = CreateTimestampWithHttpInfo(authorization, timestampRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Submission You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>ApiResponse of DefaultTimestampResponse</returns>
        public ApiResponse< DefaultTimestampResponse > CreateTimestampWithHttpInfo (string authorization, TimestampRequest timestampRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->CreateTimestamp");
            // verify the required parameter 'timestampRequest' is set
            if (timestampRequest == null)
                throw new ApiException(400, "Missing required parameter 'timestampRequest' when calling TimestampApi->CreateTimestamp");

            var localVarPath = "/v3/timestamp/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (timestampRequest != null && timestampRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(timestampRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = timestampRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateTimestamp", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultTimestampResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultTimestampResponse)));
        }

        /// <summary>
        /// Submission You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of DefaultTimestampResponse</returns>
        public async System.Threading.Tasks.Task<DefaultTimestampResponse> CreateTimestampAsync (string authorization, TimestampRequest timestampRequest)
        {
             ApiResponse<DefaultTimestampResponse> localVarResponse = await CreateTimestampAsyncWithHttpInfo(authorization, timestampRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Submission You can submit your hash with this function. If your api key is valid, your hash is added to batch and is scheduled for timestamping. If the hash already exists, the created flag in the response is set to false and the notification(s) of the current request will be totally ignored. You are also able to submit additional information, such as comment or notification credentials. Once a hash is successfully created for a certain crypto-currency, we can notify your desired target with the timestamp information (POST Request). The webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. Additionally, it is possible to include a preprint URL in the hash submission. Before the generation of the timestamp hash you can create a random UUID Version 4 and include https://originstamp.com/u/UUID where UUID is your UUID e.g. in a document you want to timestamp. In the preprint URL field you include your UUID and then it is possible to verify the timestamp within the document (or whatever). 
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="timestampRequest">DTO for the hash submission. Add all relevant information concerning your hash submission.</param>
        /// <returns>Task of ApiResponse (DefaultTimestampResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DefaultTimestampResponse>> CreateTimestampAsyncWithHttpInfo (string authorization, TimestampRequest timestampRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->CreateTimestamp");
            // verify the required parameter 'timestampRequest' is set
            if (timestampRequest == null)
                throw new ApiException(400, "Missing required parameter 'timestampRequest' when calling TimestampApi->CreateTimestamp");

            var localVarPath = "/v3/timestamp/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (timestampRequest != null && timestampRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(timestampRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = timestampRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateTimestamp", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultTimestampResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultTimestampResponse)));
        }

        /// <summary>
        /// Usage With this interface you can receive the current api usage.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>DefaultUsageResponse</returns>
        public DefaultUsageResponse GetApiKeyUsage (string authorization)
        {
             ApiResponse<DefaultUsageResponse> localVarResponse = GetApiKeyUsageWithHttpInfo(authorization);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Usage With this interface you can receive the current api usage.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>ApiResponse of DefaultUsageResponse</returns>
        public ApiResponse< DefaultUsageResponse > GetApiKeyUsageWithHttpInfo (string authorization)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetApiKeyUsage");

            var localVarPath = "/v3/api_key/usage";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetApiKeyUsage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultUsageResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultUsageResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultUsageResponse)));
        }

        /// <summary>
        /// Usage With this interface you can receive the current api usage.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>Task of DefaultUsageResponse</returns>
        public async System.Threading.Tasks.Task<DefaultUsageResponse> GetApiKeyUsageAsync (string authorization)
        {
             ApiResponse<DefaultUsageResponse> localVarResponse = await GetApiKeyUsageAsyncWithHttpInfo(authorization);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Usage With this interface you can receive the current api usage.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <returns>Task of ApiResponse (DefaultUsageResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DefaultUsageResponse>> GetApiKeyUsageAsyncWithHttpInfo (string authorization)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetApiKeyUsage");

            var localVarPath = "/v3/api_key/usage";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetApiKeyUsage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultUsageResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultUsageResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultUsageResponse)));
        }

        /// <summary>
        /// Status The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>DefaultTimestampResponse</returns>
        public DefaultTimestampResponse GetHashStatus (string authorization, string hashString)
        {
             ApiResponse<DefaultTimestampResponse> localVarResponse = GetHashStatusWithHttpInfo(authorization, hashString);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Status The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>ApiResponse of DefaultTimestampResponse</returns>
        public ApiResponse< DefaultTimestampResponse > GetHashStatusWithHttpInfo (string authorization, string hashString)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetHashStatus");
            // verify the required parameter 'hashString' is set
            if (hashString == null)
                throw new ApiException(400, "Missing required parameter 'hashString' when calling TimestampApi->GetHashStatus");

            var localVarPath = "/v3/timestamp/{hash_string}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (hashString != null) localVarPathParams.Add("hash_string", Configuration.ApiClient.ParameterToString(hashString)); // path parameter
            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetHashStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultTimestampResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultTimestampResponse)));
        }

        /// <summary>
        /// Status The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of DefaultTimestampResponse</returns>
        public async System.Threading.Tasks.Task<DefaultTimestampResponse> GetHashStatusAsync (string authorization, string hashString)
        {
             ApiResponse<DefaultTimestampResponse> localVarResponse = await GetHashStatusAsyncWithHttpInfo(authorization, hashString);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Status The request returns information of a certain hash read from the URL parameter. The input parameter is a hash in hex representation. Field \&quot;created\&quot; always set to false.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="hashString">The hash in string representation.</param>
        /// <returns>Task of ApiResponse (DefaultTimestampResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DefaultTimestampResponse>> GetHashStatusAsyncWithHttpInfo (string authorization, string hashString)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetHashStatus");
            // verify the required parameter 'hashString' is set
            if (hashString == null)
                throw new ApiException(400, "Missing required parameter 'hashString' when calling TimestampApi->GetHashStatus");

            var localVarPath = "/v3/timestamp/{hash_string}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (hashString != null) localVarPathParams.Add("hash_string", Configuration.ApiClient.ParameterToString(hashString)); // path parameter
            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetHashStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DefaultTimestampResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DefaultTimestampResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DefaultTimestampResponse)));
        }

        /// <summary>
        /// Proof This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>byte[]</returns>
        public byte[] GetProof (string authorization, ProofRequest proofRequest)
        {
             ApiResponse<byte[]> localVarResponse = GetProofWithHttpInfo(authorization, proofRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Proof This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>ApiResponse of byte[]</returns>
        public ApiResponse< byte[] > GetProofWithHttpInfo (string authorization, ProofRequest proofRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetProof");
            // verify the required parameter 'proofRequest' is set
            if (proofRequest == null)
                throw new ApiException(400, "Missing required parameter 'proofRequest' when calling TimestampApi->GetProof");

            var localVarPath = "/v3/timestamp/proof";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (proofRequest != null && proofRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(proofRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = proofRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProof", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<byte[]>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (byte[]) Configuration.ApiClient.Deserialize(localVarResponse, typeof(byte[])));
        }

        /// <summary>
        /// Proof This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>Task of byte[]</returns>
        public async System.Threading.Tasks.Task<byte[]> GetProofAsync (string authorization, ProofRequest proofRequest)
        {
             ApiResponse<byte[]> localVarResponse = await GetProofAsyncWithHttpInfo(authorization, proofRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Proof This request can be used to proof a submission of a hash. This interface is required to request the evidence. With the help of this proof the verification of a timestamp independent from OriginStamp is necessary. A guide for the verification can be found herehttps://github.com/OriginStampTimestamping/originstamp-verification . Usually, the proof should be requested for each transferred hash and kept with the timestamped data so that an independent verification of the timestamp is possible at any time. As input, the used currency, the hash string and the type of proof is required. Then a file with the information for the submission proof will be returned. If the hash was submitted in an API version lower than 3, a XML file containing the essential information of the Merkle Tree will be returned. Otherwise, the seed file will be returned.  The file name can be found in the header of the response. An example could look like this: content-disposition: attachment; filename&#x3D;\&quot;certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf\&quot; A sample XML file can be found here https://originstamp.org/assets/proof/proof_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.xml and a sample PDF can be found here https://originstamp.org/assets/proof/certificate_6d70a947e19398f1106ad70a60bd34a8305bdcb624b5b7d43782315517e79cad.pdf .
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="proofRequest">Information needed to return the hash status information.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        public async System.Threading.Tasks.Task<ApiResponse<byte[]>> GetProofAsyncWithHttpInfo (string authorization, ProofRequest proofRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->GetProof");
            // verify the required parameter 'proofRequest' is set
            if (proofRequest == null)
                throw new ApiException(400, "Missing required parameter 'proofRequest' when calling TimestampApi->GetProof");

            var localVarPath = "/v3/timestamp/proof";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (proofRequest != null && proofRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(proofRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = proofRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProof", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<byte[]>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (byte[]) Configuration.ApiClient.Deserialize(localVarResponse, typeof(byte[])));
        }

        /// <summary>
        /// Dev With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>Defaultstring</returns>
        public Defaultstring TriggerTimestampWebhook (string authorization, WebhookRequest webhookRequest)
        {
             ApiResponse<Defaultstring> localVarResponse = TriggerTimestampWebhookWithHttpInfo(authorization, webhookRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Dev With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>ApiResponse of Defaultstring</returns>
        public ApiResponse< Defaultstring > TriggerTimestampWebhookWithHttpInfo (string authorization, WebhookRequest webhookRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->TriggerTimestampWebhook");
            // verify the required parameter 'webhookRequest' is set
            if (webhookRequest == null)
                throw new ApiException(400, "Missing required parameter 'webhookRequest' when calling TimestampApi->TriggerTimestampWebhook");

            var localVarPath = "/v3/webhook/start";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (webhookRequest != null && webhookRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(webhookRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = webhookRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("TriggerTimestampWebhook", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Defaultstring>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Defaultstring) Configuration.ApiClient.Deserialize(localVarResponse, typeof(Defaultstring)));
        }

        /// <summary>
        /// Dev With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>Task of Defaultstring</returns>
        public async System.Threading.Tasks.Task<Defaultstring> TriggerTimestampWebhookAsync (string authorization, WebhookRequest webhookRequest)
        {
             ApiResponse<Defaultstring> localVarResponse = await TriggerTimestampWebhookAsyncWithHttpInfo(authorization, webhookRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Dev With this interface you can trigger manual webhook to see how a webhooks looks like. Please use a hash, that was already timestamped before such as https://originstamp.org/s/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
        /// </summary>
        /// <exception cref="OriginStamp.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization">A valid API key is essential for authorization to handle the request.</param>
        /// <param name="webhookRequest">DTO for webhook request.</param>
        /// <returns>Task of ApiResponse (Defaultstring)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Defaultstring>> TriggerTimestampWebhookAsyncWithHttpInfo (string authorization, WebhookRequest webhookRequest)
        {
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling TimestampApi->TriggerTimestampWebhook");
            // verify the required parameter 'webhookRequest' is set
            if (webhookRequest == null)
                throw new ApiException(400, "Missing required parameter 'webhookRequest' when calling TimestampApi->TriggerTimestampWebhook");

            var localVarPath = "/v3/webhook/start";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (authorization != null) localVarHeaderParams.Add("Authorization", Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (webhookRequest != null && webhookRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(webhookRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = webhookRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("TriggerTimestampWebhook", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Defaultstring>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Defaultstring) Configuration.ApiClient.Deserialize(localVarResponse, typeof(Defaultstring)));
        }

    }
}
